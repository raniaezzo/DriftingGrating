%% COMPUTE DERIVATIVES BASED ON POLAR ANGLE

% for DG - this would be both polar cardinal / polar oblique as well as
   % radial / tangential
% for DA - this would be only cartesian cardinal / oblique

function newMatrix = compute_derivativeDirections(medianBOLDpa, projectSettings, varargin)

    % Check project name
    if strcmp(projectSettings.projectName, 'da')
        % Third argument is not required for "da"
        radialvstang = 0;
        asymmetryName = 'derivedCardinalVsDerivedOblique'; % cartesian cardinal

    elseif strcmp(projectSettings.projectName, 'dg')

        % Ensure a third argument is provided for "da"
        if nargin < 3 || isempty(varargin{1})
            error('A third input is required when projectName is "dg".');
        else
            radialvstang = varargin{1};

            if radialvstang == 0
                asymmetryName = 'derivedCardinalVsDerivedOblique'; % polar cardinal
            elseif radialvstang == 1
                asymmetryName = 'radialVsTangential';
            end

        end
    else
        error('Unknown projectName. Expected "da" or "dg".');
    end

    projectName = projectSettings.projectName;
    comparisonName = projectSettings.comparisonName;
    contrasts_dict = projectSettings.contrasts_dict;

    [proConditions, conConditions, allConditions] = retrieveProConIdx(projectName, comparisonName, radialvstang);

    % Extract relevant motion direction indices
    motionDirectionIndices = allConditions;
    
%     % initialize a matrix for indexing the correct contrast value
%     motiondirs = nan(1, medianBOLDpa); % length of contrasts
% 
%     motiondirs = [nan,nan,nan,nan,nan,nan,nan, ...
%         0,90,180,270,45,135,225,315, ...
%         nan, nan, ...
%         0, 180, 90, 270, 45, 225, 135, 315, ...
%         0, 90, 45, 135];
    
    % Polar angles in the index order
    polarAngles = [90, 45, 0, 315, 270, 225, 180, 135];
    %polarAngles = [90, 135, 180, 225, 270, 315, 0, 45];
    
    % Initialize the new matrix:
    % For dg, third dimension is radial, tangential, and other
    % For da, third dimension is vertical, horizontal, and oblique
    newMatrix = zeros(3, size(medianBOLDpa, 2), size(medianBOLDpa, 3), size(medianBOLDpa, 4));
    
    for si = 1:size(medianBOLDpa, 4) % subjects
        for ri = 1:size(medianBOLDpa, 3) % region
    
            for polarIndex = 1:length(polarAngles)
                % Extract data for the current polar angle
                currentPolarData = medianBOLDpa(motionDirectionIndices, polarIndex, ri, si);
                
                radialvals = [];
                tangvals = [];
                othervals = [];
            
                for mi=motionDirectionIndices %8:15 
            
                    %motionValue = motiondirs(mi);
                    
                    % retrieve string with motion description
                    motionValue = contrasts_dict.contrasts(mi).dg_contrast_name;
                    motionValue = strsplit(motionValue, '_');
                    motionValue = motionValue{1};


                    % get the motion direction (in absolute terms)
                        % for dg - this is just the value
                        % for da, later will compute localMotionDirs per
                        % polar angle
    
                    currentVal = medianBOLDpa(mi, polarIndex, ri, si);
            
                    % check if this is correct - might need to move this out of
                    % the for loop
                    if strcmp(projectName, 'da')
                        UVM_dir = motionValue;
                        localMotionDirs = deriveLocalMotionfromUVM(UVM_dir, polarAngles);
                        currentlocalMotionDir = localMotionDirs(polarIndex);
    
                        if ismember(currentlocalMotionDir, [90, 270])
                            radialvals = [radialvals, currentVal]; % this is actually up/down
                        elseif ismember(currentlocalMotionDir, [0, 180])
                            tangvals = [tangvals, currentVal]; % this is actually right/left
                        else
                            othervals = [othervals, currentVal];
                        end
    
                    elseif strcmp(projectName, 'dg')
                        % Compute the distances between motion directions and polar angles
                        distances = abs(polarAngles(polarIndex) - motionValue);
                        
                        % Identify indices for radial, tangential, and other
                        if distances == 0 || distances == 180 
                            radialvals = [radialvals, currentVal]; % radial (in/out)
                        elseif distances == 90 || distances == 270
                            tangvals = [tangvals, currentVal]; % tangential (clock/counterclock)
                        else % other
                            othervals = [othervals, currentVal];
                        end
                    end
                end
            
                % Compute the averages and store in the new matrix
                newMatrix(1, polarIndex, ri, si) = mean(radialvals);
                newMatrix(2, polarIndex, ri, si) = mean(tangvals);
                newMatrix(3, polarIndex, ri, si) = mean(othervals);
            end
        end
    end

end